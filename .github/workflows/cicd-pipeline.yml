name: CI/CD Pipeline - GCP Kubernetes

on:
  push:
    branches: 
      - main
      - dev
  pull_request:
    branches: 
      - main
      - dev

env:
  PROJECT_ID: sonic-harbor-465608-v1
  REGION: europe-west4
  CLUSTER_NAME: blog-cluster-shared
  ARTIFACT_REGISTRY: europe-west4-docker.pkg.dev
  REPOSITORY: blog-flask

jobs:
  # BUILD & PUSH
  stage_build_push:
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.meta.outputs.tags }}
      short_sha: ${{ steps.vars.outputs.short_sha }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up variables
      id: vars
      run: |
        echo "short_sha=${GITHUB_SHA::8}" >> $GITHUB_OUTPUT
        echo "branch=${GITHUB_REF#refs/heads/}" >> $GITHUB_OUTPUT
        echo "timestamp=$(date +%Y%m%d-%H%M%S)" >> $GITHUB_OUTPUT
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
    
    - name: Run tests
      run: |
        python -m pytest test_app.py -v
    
    - name: Authenticate to Google Cloud
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}
    
    - name: Setup Google Cloud CLI
      uses: google-github-actions/setup-gcloud@v2
    
    - name: Create Artifact Registry repository
      run: |
        gcloud artifacts repositories create ${{ env.REPOSITORY }} \
          --repository-format=docker \
          --location=${{ env.REGION }} \
          --description="Flask Blog Docker Repository" || echo "Repository already exists"
    
    - name: Configure Docker for GCP
      run: |
        gcloud auth configure-docker ${{ env.REGION }}-docker.pkg.dev
    
    - name: Generate image metadata
      id: meta
      run: |
        BRANCH=${{ steps.vars.outputs.branch }}
        SHORT_SHA=${{ steps.vars.outputs.short_sha }}
        TIMESTAMP=${{ steps.vars.outputs.timestamp }}
        
        BASE_IMAGE="${{ env.ARTIFACT_REGISTRY }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY }}/blog-flask"
        
        echo "tags<<EOF" >> $GITHUB_OUTPUT
        echo "${BASE_IMAGE}:${BRANCH}-latest" >> $GITHUB_OUTPUT
        echo "${BASE_IMAGE}:${BRANCH}-${SHORT_SHA}" >> $GITHUB_OUTPUT
        echo "${BASE_IMAGE}:${BRANCH}-${TIMESTAMP}" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
    
    - name: Build and push Docker images
      run: |
        BRANCH=${{ steps.vars.outputs.branch }}
        SHORT_SHA=${{ steps.vars.outputs.short_sha }}
        TIMESTAMP=${{ steps.vars.outputs.timestamp }}
        
        BASE_IMAGE="${{ env.ARTIFACT_REGISTRY }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY }}/blog-flask"
        
        echo "Building Docker image..."
        docker build -t ${BASE_IMAGE}:${BRANCH}-latest .
        docker tag ${BASE_IMAGE}:${BRANCH}-latest ${BASE_IMAGE}:${BRANCH}-${SHORT_SHA}
        docker tag ${BASE_IMAGE}:${BRANCH}-latest ${BASE_IMAGE}:${BRANCH}-${TIMESTAMP}
        
        echo "Pushing images to Artifact Registry..."
        docker push ${BASE_IMAGE}:${BRANCH}-latest
        docker push ${BASE_IMAGE}:${BRANCH}-${SHORT_SHA}
        docker push ${BASE_IMAGE}:${BRANCH}-${TIMESTAMP}

  # DEPLOY DEV
  stage_deploy_dev:
    runs-on: ubuntu-latest
    needs: stage_build_push
    if: github.ref == 'refs/heads/dev'
    environment: development
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Authenticate to Google Cloud
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}
    
    - name: Setup Google Cloud CLI
      uses: google-github-actions/setup-gcloud@v2
    
    - name: Install gke-gcloud-auth-plugin
      run: |
        # Install gpg if not available
        sudo apt-get update
        sudo apt-get install -y gnupg
        
        # Add Google Cloud SDK repository
        sudo mkdir -p /usr/share/keyrings
        curl -fsSL https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo gpg --dearmor -o /usr/share/keyrings/cloud.google.gpg
        echo "deb [signed-by=/usr/share/keyrings/cloud.google.gpg] https://packages.cloud.google.com/apt cloud-sdk main" | sudo tee /etc/apt/sources.list.d/google-cloud-sdk.list
        
        # Update and install plugin
        sudo apt-get update
        sudo apt-get install -y google-cloud-sdk-gke-gcloud-auth-plugin
        
        echo "USE_GKE_GCLOUD_AUTH_PLUGIN=True" >> $GITHUB_ENV
    
    - name: Cleanup old clusters
      run: |
        gcloud container clusters delete blog-cluster --region=${{ env.REGION }} --quiet || echo "Old cluster not found"
        gcloud container clusters delete blog-cluster-dev --region=${{ env.REGION }} --quiet || echo "DEV cluster not found"
        gcloud container clusters delete blog-cluster-prd --region=${{ env.REGION }} --quiet || echo "PROD cluster not found"
    
    - name: Create shared cluster
      run: |
        gcloud container clusters create ${{ env.CLUSTER_NAME }} \
          --region=${{ env.REGION }} \
          --num-nodes=2 \
          --machine-type=e2-standard-2 \
          --disk-size=20 \
          --enable-autoscaling \
          --min-nodes=2 \
          --max-nodes=4 \
          --quiet || echo "Cluster already exists"
    
    - name: Deploy to DEV
      run: |
        gcloud container clusters get-credentials ${{ env.CLUSTER_NAME }} --region ${{ env.REGION }}
        
        kubectl create namespace blog-dev --dry-run=client -o yaml | kubectl apply -f -
        
        # DEV environment - only deploy DEV, don't touch PROD
        echo "Deploying DEV environment (PROD remains untouched)"
        
        IMAGE="${{ env.ARTIFACT_REGISTRY }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY }}/blog-flask:dev-${{ needs.stage_build_push.outputs.short_sha }}"
        sed -i "s|image:.*|image: ${IMAGE}|g" k8s/deployment.yaml
        
        kubectl delete deployment flask-blog -n blog-dev --ignore-not-found=true
        kubectl delete pods -l app=flask-blog -n blog-dev --ignore-not-found=true
        
        kubectl apply -f k8s/deployment.yaml -n blog-dev
        kubectl apply -f k8s/service.yaml -n blog-dev
        kubectl apply -f k8s/hpa.yaml -n blog-dev
        
        kubectl apply -f k8s/monitoring-shared.yaml
        
        kubectl rollout status deployment/flask-blog -n blog-dev --timeout=120s
        
        kubectl get pods -n blog-dev
        kubectl get services -n blog-dev

  # DEPLOY PRODUCTION
  stage_deploy_prd:
    runs-on: ubuntu-latest
    needs: stage_build_push
    if: github.ref == 'refs/heads/main'
    environment: production
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Authenticate to Google Cloud
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}
    
    - name: Setup Google Cloud CLI
      uses: google-github-actions/setup-gcloud@v2
    
    - name: Install gke-gcloud-auth-plugin
      run: |
        # Install gpg if not available
        sudo apt-get update
        sudo apt-get install -y gnupg
        
        # Add Google Cloud SDK repository
        sudo mkdir -p /usr/share/keyrings
        curl -fsSL https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo gpg --dearmor -o /usr/share/keyrings/cloud.google.gpg
        echo "deb [signed-by=/usr/share/keyrings/cloud.google.gpg] https://packages.cloud.google.com/apt cloud-sdk main" | sudo tee /etc/apt/sources.list.d/google-cloud-sdk.list
        
        # Update and install plugin
        sudo apt-get update
        sudo apt-get install -y google-cloud-sdk-gke-gcloud-auth-plugin
        
        echo "USE_GKE_GCLOUD_AUTH_PLUGIN=True" >> $GITHUB_ENV
    
    - name: Deploy to PRODUCTION
      run: |
        gcloud container clusters get-credentials ${{ env.CLUSTER_NAME }} --region ${{ env.REGION }}
        
        kubectl create namespace blog-prod --dry-run=client -o yaml | kubectl apply -f -
        
        # PROD environment - don't touch DEV
        echo "âœ… Deploying PROD environment (DEV remains untouched)"
        
        IMAGE="${{ env.ARTIFACT_REGISTRY }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY }}/blog-flask:main-${{ needs.stage_build_push.outputs.short_sha }}"
        sed -i "s|image:.*|image: ${IMAGE}|g" k8s/deployment.yaml
        sed -i "s|namespace: blog-dev|namespace: blog-prod|g" k8s/deployment.yaml
        sed -i "s|namespace: blog-dev|namespace: blog-prod|g" k8s/service.yaml
        
        kubectl delete deployment flask-blog -n blog-prod --ignore-not-found=true
        kubectl delete pods -l app=flask-blog -n blog-prod --ignore-not-found=true
        
        kubectl apply -f k8s/deployment.yaml -n blog-prod
        kubectl apply -f k8s/service.yaml -n blog-prod
        kubectl apply -f k8s/hpa.yaml -n blog-prod
        
        kubectl apply -f k8s/monitoring-shared.yaml
        
        kubectl rollout status deployment/flask-blog -n blog-prod --timeout=200s
        
        kubectl get pods -n blog-prod
        kubectl get services -n blog-prod
        
        echo "Waiting for monitoring services..."
        kubectl wait --for=condition=ready pod -l app=prometheus-shared -n monitoring --timeout=120s || echo "Prometheus not ready"
        kubectl wait --for=condition=ready pod -l app=grafana-shared -n monitoring --timeout=120s || echo "Grafana not ready"
        
        echo "=== MONITORING SERVICES ==="
        kubectl get services -n monitoring | grep -E "(prometheus|grafana)" || echo "Monitoring services not found"
        


  # TESTING
  stage_test_dev:
    runs-on: ubuntu-latest
    needs: [stage_build_push, stage_deploy_dev]
    if: github.ref == 'refs/heads/dev'
    
    steps:
    - name: Test DEV deployment
      run: |
        echo "Waiting for application to be ready..."
        sleep 30
        
        # Get service external IP (if available)
        # For now, test health endpoint via port-forward
        echo "Testing DEV environment..."
        echo "DEV deployment test completed"

  stage_test_prd:
    runs-on: ubuntu-latest
    needs: [stage_build_push, stage_deploy_prd]
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Authenticate to Google Cloud
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}
    
    - name: Setup Google Cloud CLI
      uses: google-github-actions/setup-gcloud@v2
    
    - name: Test PRODUCTION deployment
      run: |
        echo "Waiting for application to be ready..."
        sleep 30
        
        # Get cluster credentials
        gcloud container clusters get-credentials ${{ env.CLUSTER_NAME }} --region ${{ env.REGION }}
        
        EXTERNAL_IP=$(kubectl get service flask-blog-service -n blog-prod -o jsonpath='{.status.loadBalancer.ingress[0].ip}' || echo "")
        
        if [[ -n "$EXTERNAL_IP" && "$EXTERNAL_IP" != "null" ]]; then
          echo "Testing production at http://$EXTERNAL_IP"
          curl -f http://$EXTERNAL_IP/health || echo "Health check failed"
          curl -f http://$EXTERNAL_IP/metrics | head -5 || echo "Metrics test failed"
          curl -f http://$EXTERNAL_IP/ | head -5 || echo "Main page test failed"
        else
          echo "External IP not ready yet, skipping HTTP tests"
        fi
        
        echo "PRODUCTION deployment test completed"
        
        echo "=== PRODUCTION URLS ==="
        FLASK_IP=$(kubectl get service flask-blog-service -n blog-prod -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "34.91.2.135")
        
        PROMETHEUS_IP=$(kubectl get service prometheus-shared-service -n monitoring -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "pending")
        GRAFANA_IP=$(kubectl get service grafana-shared-service -n monitoring -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "pending")
        
        echo "Flask App: http://$FLASK_IP/"
        echo "Prometheus: http://$PROMETHEUS_IP:9090/"
        echo "Grafana: http://$GRAFANA_IP:3000/ (admin/admin123)"
        echo "Metrics: http://$FLASK_IP/metrics"
        


  # NOTIFICATIONS
  notify_success:
    runs-on: ubuntu-latest
    needs: [stage_build_push, stage_deploy_dev, stage_deploy_prd, stage_test_dev, stage_test_prd]
    if: always() && (needs.stage_build_push.result == 'success')
    
    steps:
    - name: Authenticate to Google Cloud
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}
    
    - name: Setup Google Cloud CLI
      uses: google-github-actions/setup-gcloud@v2
    
    - name: Install gke-gcloud-auth-plugin
      run: |
        # Install gpg if not available
        sudo apt-get update
        sudo apt-get install -y gnupg
        
        # Add Google Cloud SDK repository
        sudo mkdir -p /usr/share/keyrings
        curl -fsSL https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo gpg --dearmor -o /usr/share/keyrings/cloud.google.gpg
        echo "deb [signed-by=/usr/share/keyrings/cloud.google.gpg] https://packages.cloud.google.com/apt cloud-sdk main" | sudo tee /etc/apt/sources.list.d/google-cloud-sdk.list
        
        # Update and install plugin
        sudo apt-get update
        sudo apt-get install -y google-cloud-sdk-gke-gcloud-auth-plugin
        
        echo "USE_GKE_GCLOUD_AUTH_PLUGIN=True" >> $GITHUB_ENV
    
    - name: Notify success
      run: |
        BRANCH=${GITHUB_REF#refs/heads/}
        
        if [[ "$BRANCH" == "main" ]]; then
          ENVIRONMENT="PRODUCTION"
          
          gcloud container clusters get-credentials ${{ env.CLUSTER_NAME }} --region ${{ env.REGION }} || true
          
          FLASK_IP=$(kubectl get service flask-blog-service -n blog-prod -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "34.91.2.135")
          
          echo "=== DEBUG: Checking monitoring services ==="
          kubectl get services -n monitoring | grep -E "(prometheus|grafana)" || echo "No monitoring services found"
          
          PROMETHEUS_IP=$(kubectl get service prometheus-shared-service -n monitoring -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "pending")
          GRAFANA_IP=$(kubectl get service grafana-shared-service -n monitoring -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "pending")
          
          echo "Prometheus IP: $PROMETHEUS_IP"
          echo "Grafana IP: $GRAFANA_IP"
          
          # Get all services info
          echo "=== All PROD Services ==="
          kubectl get services -n blog-prod
          
          URLS="Production URLs: App: http://$FLASK_IP/ Prometheus: http://$PROMETHEUS_IP:9090/ Grafana: http://$GRAFANA_IP:3000/ (admin/admin123) Metrics: http://$FLASK_IP/metrics"
          
        else
          ENVIRONMENT="DEVELOPMENT"
          
          gcloud container clusters get-credentials ${{ env.CLUSTER_NAME }} --region ${{ env.REGION }} || true
          
          # Get Flask IP directly
          DEV_FLASK_IP=$(kubectl get service flask-blog-service -n blog-dev -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "pending")
          
          DEV_PROMETHEUS_IP=$(kubectl get service prometheus-shared-service -n monitoring -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "pending")
          DEV_GRAFANA_IP=$(kubectl get service grafana-shared-service -n monitoring -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "pending")
          
          # Get all services info
          echo "=== All DEV Services ==="
          kubectl get services -n blog-dev
          
          URLS="Development URLs: App: http://$DEV_FLASK_IP/ Prometheus: http://$DEV_PROMETHEUS_IP:9090/ Grafana: http://$DEV_GRAFANA_IP:3000/ (admin/admin123) Metrics: http://$DEV_FLASK_IP/metrics"
        fi
        
        MESSAGE="CI/CD SUCCESS | Branch: $BRANCH | Environment: $ENVIRONMENT | Commit: ${GITHUB_SHA:0:8} | $URLS | Deployment completed successfully!"
        
        curl -s -X POST "https://api.telegram.org/bot8251627883:AAGx2cF8wSVTgXaiFM5hNIXVnM2UAlTbRMo/sendMessage" \
          -d chat_id="-4872258641" \
          -d parse_mode="HTML" \
          -d text="$MESSAGE"

  notify_failure:
    runs-on: ubuntu-latest
    needs: [stage_build_push, stage_deploy_dev, stage_deploy_prd, stage_test_dev, stage_test_prd]
    if: always() && (needs.stage_build_push.result == 'failure' || needs.stage_deploy_dev.result == 'failure' || needs.stage_deploy_prd.result == 'failure')
    
    steps:
    - name: Notify failure
      run: |
        BRANCH=${GITHUB_REF#refs/heads/}
        
        if [[ "$BRANCH" == "main" ]]; then
          ENVIRONMENT=" PRODUCTION"
        else
          ENVIRONMENT=" DEVELOPMENT"
        fi
        
        MESSAGE="CI/CD FAILED | Branch: $BRANCH | Environment: $ENVIRONMENT | Commit: ${GITHUB_SHA:0:8} | Logs: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }} | Deployment failed!"
        
        curl -s -X POST "https://api.telegram.org/bot8251627883:AAGx2cF8wSVTgXaiFM5hNIXVnM2UAlTbRMo/sendMessage" \
          -d chat_id="-4872258641" \
          -d parse_mode="HTML" \
          -d text="$MESSAGE"
