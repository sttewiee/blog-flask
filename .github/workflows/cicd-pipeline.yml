name: CI/CD Pipeline - GCP Kubernetes

on:
  push:
    branches: 
      - main
      - dev
  pull_request:
    branches: 
      - main
      - dev

env:
  PROJECT_ID: sonic-harbor-465608-v1
  REGION: europe-west4
  CLUSTER_NAME: blog-cluster-shared
  ARTIFACT_REGISTRY: europe-west4-docker.pkg.dev
  REPOSITORY: blog-flask

jobs:
  # BUILD, TEST & PUSH DOCKER IMAGE
  stage_build_test_push:
    runs-on: ubuntu-latest
    outputs:
      short_sha: ${{ steps.vars.outputs.short_sha }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up build variables
      id: vars
      run: |
        echo "short_sha=${GITHUB_SHA::8}" >> $GITHUB_OUTPUT
        echo "branch=${GITHUB_REF#refs/heads/}" >> $GITHUB_OUTPUT
        echo "timestamp=$(date +%Y%m%d-%H%M%S)" >> $GITHUB_OUTPUT
    
    - name: Set up Python environment
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install Python dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
    
    - name: Run unit tests
      run: |
        python -m pytest test_app.py -v
    
    - name: Authenticate to Google Cloud
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}
    
    - name: Setup Google Cloud CLI
      uses: google-github-actions/setup-gcloud@v2
    
    - name: Create Docker Artifact Registry repository
      run: |
        gcloud artifacts repositories create ${{ env.REPOSITORY }} \
          --repository-format=docker \
          --location=${{ env.REGION }} \
          --description="Flask Blog Docker Repository" || echo "Repository already exists"
    
    - name: Configure Docker for Google Artifact Registry
      run: |
        gcloud auth configure-docker ${{ env.REGION }}-docker.pkg.dev --quiet
    

    
    - name: Build and push Docker images to Artifact Registry
      run: |
        BRANCH=${{ steps.vars.outputs.branch }}
        SHORT_SHA=${{ steps.vars.outputs.short_sha }}
        TIMESTAMP=${{ steps.vars.outputs.timestamp }}
        
        BASE_IMAGE="${{ env.ARTIFACT_REGISTRY }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY }}/blog-flask"
        
        echo "Building Docker image..."
        docker build -t ${BASE_IMAGE}:${BRANCH}-latest .
        docker tag ${BASE_IMAGE}:${BRANCH}-latest ${BASE_IMAGE}:${BRANCH}-${SHORT_SHA}
        docker tag ${BASE_IMAGE}:${BRANCH}-latest ${BASE_IMAGE}:${BRANCH}-${TIMESTAMP}
        
        echo "Pushing images to Artifact Registry..."
        docker push ${BASE_IMAGE}:${BRANCH}-latest
        docker push ${BASE_IMAGE}:${BRANCH}-${SHORT_SHA}
        docker push ${BASE_IMAGE}:${BRANCH}-${TIMESTAMP}
        
        echo "Pushed images:"
        echo "  - ${BASE_IMAGE}:${BRANCH}-latest"
        echo "  - ${BASE_IMAGE}:${BRANCH}-${SHORT_SHA}"
        echo "  - ${BASE_IMAGE}:${BRANCH}-${TIMESTAMP}"

  # DEPLOY TO DEVELOPMENT ENVIRONMENT
  stage_deploy_dev:
    runs-on: ubuntu-latest
    needs: stage_build_test_push
    if: github.ref == 'refs/heads/dev'
    environment: development
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Authenticate to Google Cloud
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}
    
    - name: Setup Google Cloud CLI
      uses: google-github-actions/setup-gcloud@v2
    
    - name: Install gke-gcloud-auth-plugin
      run: |
        # Install gpg if not available
        sudo apt-get update
        sudo apt-get install -y gnupg
        
        # Add Google Cloud SDK repository
        sudo mkdir -p /usr/share/keyrings
        curl -fsSL https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo gpg --dearmor -o /usr/share/keyrings/cloud.google.gpg
        echo "deb [signed-by=/usr/share/keyrings/cloud.google.gpg] https://packages.cloud.google.com/apt cloud-sdk main" | sudo tee /etc/apt/sources.list.d/google-cloud-sdk.list
        
        # Update and install plugin
        sudo apt-get update
        sudo apt-get install -y google-cloud-sdk-gke-gcloud-auth-plugin
        
        echo "USE_GKE_GCLOUD_AUTH_PLUGIN=True" >> $GITHUB_ENV
    
    - name: Check if GKE cluster exists
      run: |
        echo "✅ Checking if cluster exists..."
        gcloud container clusters describe ${{ env.CLUSTER_NAME }} --region=${{ env.REGION }} --quiet || echo "Cluster not found"
    
    - name: Create GKE cluster if not exists
      run: |
        if ! gcloud container clusters describe "${{ env.CLUSTER_NAME }}" --region "${{ env.REGION }}" >/dev/null 2>&1; then
          echo "Creating cluster ${{ env.CLUSTER_NAME }}..."
          gcloud container clusters create ${{ env.CLUSTER_NAME }} \
            --region=${{ env.REGION }} \
            --num-nodes=2 \
            --machine-type=e2-standard-2 \
            --disk-size=20 \
            --enable-autoscaling \
            --min-nodes=2 \
            --max-nodes=4 \
            --quiet
        else
          echo "✅ Cluster ${{ env.CLUSTER_NAME }} already exists"
        fi
    
    - name: Deploy application to DEV environment
      run: |
        gcloud container clusters get-credentials ${{ env.CLUSTER_NAME }} --region ${{ env.REGION }}
        
        kubectl create namespace blog-dev --dry-run=client -o yaml | kubectl apply -f -
        
        # DEV environment - only deploy DEV, don't touch PROD
        echo "Deploying DEV environment (PROD remains untouched)"
        
        # Берём short_sha из outputs, а если вдруг пусто — считаем локально
        SHORT_SHA="${{ needs.stage_build_test_push.outputs.short_sha }}"
        if [[ -z "$SHORT_SHA" ]]; then
          SHORT_SHA="${GITHUB_SHA:0:8}"
          echo "WARN: needs.stage_build_test_push.outputs.short_sha is empty, fallback to ${SHORT_SHA}"
        fi
        
        IMAGE="${{ env.ARTIFACT_REGISTRY }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY }}/blog-flask:dev-${SHORT_SHA}"
        echo "Using image: ${IMAGE}"
        
        # Проверка доступности образа (опционально)
        echo "Checking if image exists in registry..."
        gcloud artifacts docker images list ${IMAGE%:*} --include-tags | grep "${IMAGE#*:}" || {
          echo "WARN: Image ${IMAGE} not found in registry, but continuing deployment..."
        }
        
        # Apply deployment first
        kubectl apply -f k8s/deployment.yaml -n blog-dev
        
        # Update image using kubectl set image (more reliable than sed)
        kubectl set image deployment/flask-blog flask-blog="${IMAGE}" -n blog-dev
        
        kubectl apply -f k8s/service.yaml -n blog-dev
        kubectl apply -f k8s/hpa-dev.yaml -n blog-dev
        
        kubectl apply -f k8s/monitoring-shared.yaml
        
        # Ждём подольше и при фейле — даём диагностику
        set +e
        kubectl rollout status deployment/flask-blog -n blog-dev --timeout=300s
        R=$?
        set -e
        if [[ $R -ne 0 ]]; then
          echo "=== DEBUG: Deployment/RS/Pods ==="
          kubectl get deploy/flask-blog -n blog-dev -o wide
          kubectl get rs -n blog-dev -o wide --sort-by=.metadata.creationTimestamp
          kubectl get pods -n blog-dev -o wide
          echo "=== DESCRIBE latest pods ==="
          kubectl describe pods -n blog-dev | sed -n '1,200p'
          echo "=== Recent events ==="
          kubectl get events -n blog-dev --sort-by=.metadata.creationTimestamp | tail -n 100
          exit 1
        fi
        
        kubectl get pods -n blog-dev
        kubectl get services -n blog-dev

  # DEPLOY TO PRODUCTION ENVIRONMENT
  stage_deploy_prd:
    runs-on: ubuntu-latest
    needs: stage_build_test_push
    if: github.ref == 'refs/heads/main'
    environment: production
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Authenticate to Google Cloud
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}
    
    - name: Setup Google Cloud CLI
      uses: google-github-actions/setup-gcloud@v2
    
    - name: Install gke-gcloud-auth-plugin
      run: |
        # Install gpg if not available
        sudo apt-get update
        sudo apt-get install -y gnupg
        
        # Add Google Cloud SDK repository
        sudo mkdir -p /usr/share/keyrings
        curl -fsSL https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo gpg --dearmor -o /usr/share/keyrings/cloud.google.gpg
        echo "deb [signed-by=/usr/share/keyrings/cloud.google.gpg] https://packages.cloud.google.com/apt cloud-sdk main" | sudo tee /etc/apt/sources.list.d/google-cloud-sdk.list
        
        # Update and install plugin
        sudo apt-get update
        sudo apt-get install -y google-cloud-sdk-gke-gcloud-auth-plugin
        
        echo "USE_GKE_GCLOUD_AUTH_PLUGIN=True" >> $GITHUB_ENV
    
    - name: Deploy application to PRODUCTION environment
      run: |
        gcloud container clusters get-credentials ${{ env.CLUSTER_NAME }} --region ${{ env.REGION }}
        
        kubectl create namespace blog-prod --dry-run=client -o yaml | kubectl apply -f -
        

        
        # PROD environment - don't touch DEV
        echo "✅ Deploying PROD environment (DEV remains untouched)"
        
        # Берём short_sha из outputs, а если вдруг пусто — считаем локально
        SHORT_SHA="${{ needs.stage_build_test_push.outputs.short_sha }}"
        if [[ -z "$SHORT_SHA" ]]; then
          SHORT_SHA="${GITHUB_SHA:0:8}"
          echo "WARN: needs.stage_build_test_push.outputs.short_sha is empty, fallback to ${SHORT_SHA}"
        fi
        
        IMAGE="${{ env.ARTIFACT_REGISTRY }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY }}/blog-flask:main-${SHORT_SHA}"
        echo "Using image: ${IMAGE}"
        
        # Проверка доступности образа (опционально)
        echo "Checking if image exists in registry..."
        gcloud artifacts docker images list ${IMAGE%:*} --include-tags | grep "${IMAGE#*:}" || {
          echo "WARN: Image ${IMAGE} not found in registry, but continuing deployment..."
        }
        
        # Apply deployment first
        kubectl apply -f k8s/deployment.yaml -n blog-prod
        
        # Update image using kubectl set image (more reliable than sed)
        kubectl set image deployment/flask-blog flask-blog="${IMAGE}" -n blog-prod
        
        kubectl apply -f k8s/service.yaml -n blog-prod
        kubectl apply -f k8s/hpa-prod.yaml -n blog-prod
        
        kubectl apply -f k8s/monitoring-shared.yaml
        
        # Ждём подольше и при фейле — даём диагностику
        set +e
        kubectl rollout status deployment/flask-blog -n blog-prod --timeout=300s
        R=$?
        set -e
        if [[ $R -ne 0 ]]; then
          echo "=== DEBUG: Deployment/RS/Pods ==="
          kubectl get deploy/flask-blog -n blog-prod -o wide
          kubectl get rs -n blog-prod -o wide --sort-by=.metadata.creationTimestamp
          kubectl get pods -n blog-prod -o wide
          echo "=== DESCRIBE latest pods ==="
          kubectl describe pods -n blog-prod | sed -n '1,200p'
          echo "=== Recent events ==="
          kubectl get events -n blog-prod --sort-by=.metadata.creationTimestamp | tail -n 100
          exit 1
        fi
        
        kubectl get pods -n blog-prod
        kubectl get services -n blog-prod
        
        # Update DuckDNS for PROD
        echo "Updating DuckDNS for PROD..."
        EXTERNAL_IP=$(kubectl get service flask-blog-service -n blog-prod -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
        if [[ -n "$EXTERNAL_IP" && "$EXTERNAL_IP" != "null" ]]; then
          echo "Updating lapikov.duckdns.org with IP: $EXTERNAL_IP"
          curl -s "https://www.duckdns.org/update?domains=lapikov&token=413beafc-50cf-429f-94fc-be114815acab&ip=$EXTERNAL_IP"
          echo "DuckDNS update completed"
          
          # Wait for DNS propagation and check HTTP
          echo "Waiting for DNS propagation..."
          sleep 30
          curl -I http://lapikov.duckdns.org || echo "HTTP not ready yet"
        else
          echo "External IP not ready, skipping DuckDNS update"
        fi
        
        echo "Waiting for monitoring services..."
        kubectl wait --for=condition=ready pod -l app=prometheus-shared -n monitoring --timeout=120s || echo "Prometheus not ready"
        kubectl wait --for=condition=ready pod -l app=grafana-shared -n monitoring --timeout=120s || echo "Grafana not ready"
        
        echo "=== MONITORING SERVICES ==="
        kubectl get services -n monitoring | grep -E "(prometheus|grafana)" || echo "Monitoring services not found"
        


  # TEST DEVELOPMENT ENVIRONMENT
  stage_test_dev:
    runs-on: ubuntu-latest
    needs: [stage_build_test_push, stage_deploy_dev]
    if: github.ref == 'refs/heads/dev'
    
    steps:
    - name: Authenticate to Google Cloud
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}
    
    - name: Setup Google Cloud CLI
      uses: google-github-actions/setup-gcloud@v2
    
    - name: Install gke-gcloud-auth-plugin
      run: |
        sudo apt-get update
        sudo apt-get install -y gnupg
        sudo mkdir -p /usr/share/keyrings
        curl -fsSL https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo gpg --dearmor -o /usr/share/keyrings/cloud.google.gpg
        echo "deb [signed-by=/usr/share/keyrings/cloud.google.gpg] https://packages.cloud.google.com/apt cloud-sdk main" | sudo tee /etc/apt/sources.list.d/google-cloud-sdk.list
        sudo apt-get update
        sudo apt-get install -y google-cloud-sdk-gke-gcloud-auth-plugin kubectl
        echo "USE_GKE_GCLOUD_AUTH_PLUGIN=True" >> $GITHUB_ENV
    
    - name: Test DEV environment deployment
      run: |
        echo "Waiting for application to be ready..."
        sleep 30
        
        # Get cluster credentials
        gcloud container clusters get-credentials ${{ env.CLUSTER_NAME }} --region ${{ env.REGION }}
        
        # Попытка получить внешний IP
        set +e
        EXTERNAL_IP=$(kubectl get service flask-blog-service -n blog-dev -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
        RC=$?
        set -e
        
        if [[ $RC -eq 0 && -n "$EXTERNAL_IP" && "$EXTERNAL_IP" != "null" ]]; then
          echo "Testing DEV at http://$EXTERNAL_IP"
          curl -f http://$EXTERNAL_IP/health || echo "Health check failed"
          curl -f http://$EXTERNAL_IP/metrics | head -5 || echo "Metrics test failed"
          curl -f http://$EXTERNAL_IP/ | head -5 || echo "Main page test failed"
        else
          echo "External IP not ready, using port-forward"
          kubectl port-forward service/flask-blog-service 8080:80 -n blog-dev &
          PF_PID=$!
          trap "kill $PF_PID" EXIT
          sleep 8
          curl -f http://localhost:8080/health || echo "Health check failed"
          curl -f http://localhost:8080/metrics | head -5 || echo "Metrics test failed"
          curl -f http://localhost:8080/ | head -5 || echo "Main page test failed"
        fi
        
        echo "DEV deployment test completed"

  # TEST PRODUCTION ENVIRONMENT
  stage_test_prd:
    runs-on: ubuntu-latest
    needs: [stage_build_test_push, stage_deploy_prd]
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Authenticate to Google Cloud
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}
    
    - name: Setup Google Cloud CLI
      uses: google-github-actions/setup-gcloud@v2
    
    - name: Install gke-gcloud-auth-plugin
      run: |
        sudo apt-get update
        sudo apt-get install -y gnupg
        sudo mkdir -p /usr/share/keyrings
        curl -fsSL https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo gpg --dearmor -o /usr/share/keyrings/cloud.google.gpg
        echo "deb [signed-by=/usr/share/keyrings/cloud.google.gpg] https://packages.cloud.google.com/apt cloud-sdk main" | sudo tee /etc/apt/sources.list.d/google-cloud-sdk.list
        sudo apt-get update
        sudo apt-get install -y google-cloud-sdk-gke-gcloud-auth-plugin kubectl
        echo "USE_GKE_GCLOUD_AUTH_PLUGIN=True" >> $GITHUB_ENV
    
    - name: Test PRODUCTION environment deployment
      run: |
        echo "Waiting for application to be ready..."
        sleep 30
        
        # Get cluster credentials
        gcloud container clusters get-credentials ${{ env.CLUSTER_NAME }} --region ${{ env.REGION }}
        
        EXTERNAL_IP=$(kubectl get service flask-blog-service -n blog-prod -o jsonpath='{.status.loadBalancer.ingress[0].ip}' || echo "")
        
        if [[ -n "$EXTERNAL_IP" && "$EXTERNAL_IP" != "null" ]]; then
          echo "Testing production at http://$EXTERNAL_IP"
          curl -f http://$EXTERNAL_IP/health || echo "Health check failed"
          curl -f http://$EXTERNAL_IP/metrics | head -5 || echo "Metrics test failed"
          curl -f http://$EXTERNAL_IP/ | head -5 || echo "Main page test failed"
        else
          echo "External IP not ready yet, skipping HTTP tests"
        fi
        
        echo "PRODUCTION deployment test completed"
        
        echo "=== PRODUCTION URLS ==="
        FLASK_IP=$(kubectl get service flask-blog-service -n blog-prod -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "34.91.2.135")
        
        PROMETHEUS_IP=$(kubectl get service prometheus-shared-service -n monitoring -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "pending")
        GRAFANA_IP=$(kubectl get service grafana-shared-service -n monitoring -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "pending")
        
        echo "Flask App: http://$FLASK_IP/"
        echo "Prometheus: http://$PROMETHEUS_IP:9090/"
        echo "Grafana: http://$GRAFANA_IP:3000/ (admin/admin123)"
        echo "Metrics: http://$FLASK_IP/metrics"
        


  # SEND SUCCESS NOTIFICATIONS
  notify_success:
    runs-on: ubuntu-latest
    needs: [stage_build_test_push, stage_deploy_dev, stage_deploy_prd, stage_test_dev, stage_test_prd]
    if: |
      always() && 
      needs.stage_build_test_push.result == 'success' && 
      (
        (github.ref == 'refs/heads/main' && needs.stage_deploy_prd.result == 'success') ||
        (github.ref == 'refs/heads/dev' && needs.stage_deploy_dev.result == 'success')
      )
    
    steps:
    - name: Authenticate to Google Cloud
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}
    
    - name: Setup Google Cloud CLI
      uses: google-github-actions/setup-gcloud@v2
    
    - name: Install gke-gcloud-auth-plugin
      run: |
        # Install gpg if not available
        sudo apt-get update
        sudo apt-get install -y gnupg
        
        # Add Google Cloud SDK repository
        sudo mkdir -p /usr/share/keyrings
        curl -fsSL https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo gpg --dearmor -o /usr/share/keyrings/cloud.google.gpg
        echo "deb [signed-by=/usr/share/keyrings/cloud.google.gpg] https://packages.cloud.google.com/apt cloud-sdk main" | sudo tee /etc/apt/sources.list.d/google-cloud-sdk.list
        
        # Update and install plugin
        sudo apt-get update
        sudo apt-get install -y google-cloud-sdk-gke-gcloud-auth-plugin
        
        echo "USE_GKE_GCLOUD_AUTH_PLUGIN=True" >> $GITHUB_ENV
    
    - name: Send success notification to Telegram
      run: |
        BRANCH=${GITHUB_REF#refs/heads/}
        
        if [[ "$BRANCH" == "main" ]]; then
          ENVIRONMENT="PRODUCTION"
          
          gcloud container clusters get-credentials ${{ env.CLUSTER_NAME }} --region ${{ env.REGION }} || true
          
          FLASK_IP=$(kubectl get service flask-blog-service -n blog-prod -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "34.91.2.135")
          
          echo "=== DEBUG: Checking monitoring services ==="
          kubectl get services -n monitoring | grep -E "(prometheus|grafana)" || echo "No monitoring services found"
          
          PROMETHEUS_IP=$(kubectl get service prometheus-shared-service -n monitoring -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "pending")
          GRAFANA_IP=$(kubectl get service grafana-shared-service -n monitoring -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "pending")
          
          echo "Prometheus IP: $PROMETHEUS_IP"
          echo "Grafana IP: $GRAFANA_IP"
          
          # Get all services info
          echo "=== All PROD Services ==="
          kubectl get services -n blog-prod
          
          URLS="Production URLs: App: http://$FLASK_IP/ Prometheus: http://$PROMETHEUS_IP:9090/ Grafana: http://$GRAFANA_IP:3000/ (admin/admin123) Metrics: http://$FLASK_IP/metrics"
          
        else
          ENVIRONMENT="DEVELOPMENT"
          
          gcloud container clusters get-credentials ${{ env.CLUSTER_NAME }} --region ${{ env.REGION }} || true
          
          # Get Flask IP directly
          DEV_FLASK_IP=$(kubectl get service flask-blog-service -n blog-dev -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "pending")
          
          DEV_PROMETHEUS_IP=$(kubectl get service prometheus-shared-service -n monitoring -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "pending")
          DEV_GRAFANA_IP=$(kubectl get service grafana-shared-service -n monitoring -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "pending")
          
          # Get all services info
          echo "=== All DEV Services ==="
          kubectl get services -n blog-dev
          
          URLS="Development URLs: App: http://$DEV_FLASK_IP/ Prometheus: http://$DEV_PROMETHEUS_IP:9090/ Grafana: http://$DEV_GRAFANA_IP:3000/ (admin/admin123) Metrics: http://$DEV_FLASK_IP/metrics"
        fi
        
        MESSAGE="CI/CD SUCCESS | Branch: $BRANCH | Environment: $ENVIRONMENT | Commit: ${GITHUB_SHA:0:8} | $URLS | Deployment completed successfully!"
        
        curl -s -X POST "https://api.telegram.org/bot8251627883:AAGx2cF8wSVTgXaiFM5hNIXVnM2UAlTbRMo/sendMessage" \
          -d chat_id="-4872258641" \
          -d parse_mode="HTML" \
          -d text="$MESSAGE"

  # SEND FAILURE NOTIFICATIONS
  notify_failure:
    runs-on: ubuntu-latest
    needs: [stage_build_test_push, stage_deploy_dev, stage_deploy_prd, stage_test_dev, stage_test_prd]
    if: always() && (needs.stage_build_test_push.result == 'failure' || needs.stage_deploy_dev.result == 'failure' || needs.stage_deploy_prd.result == 'failure')
    
    steps:
    - name: Send failure notification to Telegram
      run: |
        BRANCH=${GITHUB_REF#refs/heads/}
        
        if [[ "$BRANCH" == "main" ]]; then
          ENVIRONMENT=" PRODUCTION"
        else
          ENVIRONMENT=" DEVELOPMENT"
        fi
        
        MESSAGE="CI/CD FAILED | Branch: $BRANCH | Environment: $ENVIRONMENT | Commit: ${GITHUB_SHA:0:8} | Logs: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }} | Deployment failed!"
        
        curl -s -X POST "https://api.telegram.org/bot8251627883:AAGx2cF8wSVTgXaiFM5hNIXVnM2UAlTbRMo/sendMessage" \
          -d chat_id="-4872258641" \
          -d parse_mode="HTML" \
          -d text="$MESSAGE"
